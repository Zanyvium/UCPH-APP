#ifndef SPARSE_VECTOR_HPP
#define SPARSE_VECTOR_HPP

#include <iostream>
#include <string>
#include <cassert>
#include <typeinfo>
//#include <type_traits>

#include <vector>
#include <algorithm>

#include "Vector.hpp"
#include "Matrix.hpp"

template<class T> class SparseVector{
private:
	unsigned int mDim;
	std::vector<unsigned int> mIndices;
	std::vector<T> mValues;

public:
	//creates an empty vector of dimensionality 0.
	SparseVector() = default;
	// Creates a vector of dimensionality dim. It starts with 0 nonzero elements
	// which need to be set using setValue
	SparseVector(unsigned int dim);

	//SparseVector(unsigned int dim, std::vector<unsigned int> indices, std::vector<T> values);

	// assignment operators and copy constructor should be automatically
	// generated by the compiler when using a std::vector for internal storing.
	// However, test that assignment works!

	//sets the value v_i of the vector. If it does not exist it is added
	void setValue(unsigned int index, T value);

	//returns the value v_i of the vector. Returns 0 if the value is not stored
	T getValue(unsigned int index) const;

	//returns the dimensionality of the vector
	unsigned int size() const;

	// returns the number stored elements
	unsigned int nonZeroes() const;
	//returns the index of the ith stored nonzero entry (in increasing order)
	unsigned int indexNonZero(unsigned int i) const;
	//returns the value of the ith stored nonzero entry (in increasing order)
	T valueNonZero(unsigned int i) const;

	//adds x too the current vector
	SparseVector<T>& operator+= (SparseVector<T> const& x);
	//subtracts x from the current vector
	SparseVector<T>& operator-= (SparseVector<T> const& x);

};
/* 
template<class T> std::vector<T> getSparse(SparseVector<T>& sv, std::string sv_name = "sv");
template<class T> void printSparse(SparseVector<T>& sv, std::string sv_name = "sv"); */

//creates an empty vector of dimensionality 0.
/* template<class T> SparseVector<T>::SparseVector() {
	mDim = 0;
} */

// Creates a vector of dimensionality dim. It starts with 0 nonzero elements
// which need to be set using setValue
template<class T> SparseVector<T>::SparseVector(unsigned int dim) {
	mDim = dim;
	mIndices.reserve(dim);
	mValues.reserve(dim);
}

/* template<class T> SparseVector<T>::SparseVector(unsigned int dim, std::vector<unsigned int> indices, std::vector<T> values) {
	mDim = dim;
	mIndices = indices;
	mValues = values;
} */

/* // Search for first element x such that i â‰¤ x
auto lower = std::lower_bound(data.begin(), data.end(), i); */

//sets the value v_i of the vector. If it does not exist it is added
template<class T> void SparseVector<T>::setValue(unsigned int index, T value) {
	//???What if we have value = 0?!!!!
	//!!! <- assignment says doesn't matter.


	//mDim = max(mDim,index), such that mDim is atleast of size index
	//note the +1 in order to facilitate that a SV with its farthest
	//entry set at index 8, has nine entries. 
	mDim = (mDim>=index+1) ? mDim : index+1;

	if (mIndices.size() == 0) {
		//there are no other non-zero entries.
		//we insert the index and value provided directly.
		
		mValues.push_back(value);
		mIndices.push_back(index);

/* 		if (value != 0) {
			mValues.push_back(value);
			mIndices.push_back(index);
		} */

		//for mIndices.size() != 0 "else case" below, method below would work if not for segmentation
		//problems with the conditional checking whether bound content is equal to index in case of the "empty vector".
		//!!! <- (see tests)

	} else {
		//there are other non-zero entries.
		//check whether 

		//bound is iterator of the smallest index i for which i>=index
		auto bound = std::lower_bound(mIndices.begin(), mIndices.end(), index);

		//[i]-style index location of insertion in mIndices 
		//(how long have we 'stepped' relative to the beginning of mIndices to find bound)
		unsigned int relative_steps_in_i = bound - mIndices.begin(); 

		auto val_it = mValues.begin();
		//??? what if value = 0 ?
		if (*bound == index) {
			//index is in mI, thus erase mV at bound and insert val at location of mValues corresponding to bound location in mIndices.
			//!!! <- note required use of a mValues iterator, as this otherwise yields a convertion error 
			//!!! <- (you can not iterate on a double object with an int iterator)
			mValues.erase(val_it+relative_steps_in_i);
		} else {
			//index is not in mI, thus index in mI after(!) bound, and  insert val in mV after(!) bound.
			mIndices.insert(bound, index);
		}
		//either way, insert value after bound.
		mValues.insert(val_it+relative_steps_in_i, value);
	}
}

//returns the value v_i of the vector. Returns 0 if the value is not stored
template<class T> T SparseVector<T>::getValue(unsigned int index) const {
	auto search_it = std::find(mIndices.begin(), mIndices.end(), index);
	if (search_it != mIndices.end()) {
		int position_found = search_it - mIndices.begin();
		return mValues[position_found];

		//auto mValues_begin_it = mValues.begin();
		//return *(mValues_begin_it + position_found);
	} else {
		return 0;
	}
}


//returns the dimensionality of the vector
template<class T> unsigned int SparseVector<T>::size() const {
	return mDim;
}

// returns the number stored elements
template<class T> unsigned int SparseVector<T>::nonZeroes() const {
	return (unsigned int)(mIndices.size());
}

//returns the index of the ith stored nonzero entry (in increasing order)
template<class T> unsigned int SparseVector<T>::indexNonZero(unsigned int i) const {
	assert(mIndices.size() >= i+1); //if we do not have i+1 non-zero entries, trigger assertion
	return mIndices[i];
}

//returns the value of the ith stored nonzero entry (in increasing order)
template<class T> T SparseVector<T>::valueNonZero(unsigned int i) const {
	assert(mValues.size() >= i+1);
	return mValues[i];
}


//non-member helper function to get the full sparse vector.
template<class T> std::vector<T> getSparse(SparseVector<T>& sv) {
	unsigned int dim = sv.size();
	std::vector<T> result(dim);
	for (unsigned int i = 0; i < dim; i++) {
		result[i] = sv.getValue(i);
	}
	return result;
}

//non-member helper function to set a sparse vector.
template<class T> SparseVector<T> setSparse(std::vector<T>& v) {
	unsigned int v_size = v.size();
	SparseVector<T> sv(v_size);
	for(int i = 0; i < v_size; i++) {
		if(v[i] !=0) {
			sv.setValue(i,v[i]);
		}
	}
	return sv;
}

//non-member helper function to print the full sparse vector.
template<class T> void printSparse(SparseVector<T>& sv, std::string sv_name = "sv") {
	unsigned int dim = sv.size();
	std::cout << "dim: " << dim << std::endl;
	std::cout << "# non zero: " << sv.nonZeroes() << std::endl;
	std::vector<T> result = getSparse(sv);
	std::cout << sv_name << std::endl;
	for (auto elm : result) {
		std::cout << elm << " ";
	}
	std::cout << std::endl;
}

//adds x to the current vector
template<class T> SparseVector<T>& SparseVector<T>::operator+= (SparseVector<T> const& x) {
	//??? did I do += or just +?

	//Potentially, we could allow addition of unequal sized SVs (but that would be a somewhat off += operator)
	//by expanding the dimension (adding zeros) of the one, to the size of the other.
	//We however do a simpler version of asserting them to be of the same size.
	assert(mDim == x.mDim);

	//two different approaches: 
		//1. 
			//create a std::vector<unsigned int> unionVec which is the union of mIndices and x.mIndides
			//sort this union vector.
			//create unsigned int result_size = unionVec.size();
			//create a std::vector<T> vals(result_size), for values.
			//for (int i = 0; i < result_size; i++) { vals[i] = this.getValue(unionVec[i]) + x.getValue(unionVec[i]); }
			//with unionVec and vals, we may thus create SparseVector<T> result(mDim);
			//then: for (unsigned int i = 0; i < result_size; i++) {	result.setValue(unionVec[i],vals[i]); }
			//return result;
			
		//2. 
			//create std::vector<unsigned int> indices, and std::vector<T> vals; 
			//loop over pairwise entries of of mIndices and x.mIndices:
			//start off by looping over all entries of x.mIndices. For each of these entries, loop over all entries of mIndices
			//for each entry of x.mIndices, if there is a equal entry in mIndices, save a record of their value summation,... 
			//...delete previous entry of mValues corresponding to the index, and insert the summation
			//if for the entry of x.mIndices, no equal mIndices entry can be found, (i.e. there's an entry at a location in x which is not in this),...
			//...add the index (at the correct place) to mIndices, and add the of x at the index to mValues as well. 
			//by such a method, all entries (think Venn-diagram of this \cap x \cup x\not this) will be added to mValues.
			//and as mValues and mIndices already contain their respective entries associated with this, we can return this.  
	
	//we go with implementing 1.

	std::vector<unsigned int> unionVec(this->mIndices); 
	std::vector<unsigned int> const x_index(x.mIndices);

	//add the entries of x_index to the end of this.mIndices, thus collecting all non-zero indices
	unionVec.insert(unionVec.end(), x_index.begin(), x_index.end());

	//unionVec will however not be sorted, and may have multiple occurances of the same entry.
	//Thus, we sort unionVec
	std::sort(unionVec.begin(),unionVec.end());

	//and then we remove duplicate entries, such that only one of each unique entry appears
	unionVec.erase(std::unique(unionVec.begin(), unionVec.end()), unionVec.end());

	//get the size of the resulting union of the two index-vectors
	unsigned int unionVec_size = unionVec.size();
	
	//create a std::vector<T> vector for the non-zero values of the SparseVector to be returned
	std::vector<T> vals(unionVec_size);

	//loop over the union indices and collect the values.
	for (unsigned int i = 0; i < unionVec_size; i++) {
		this->setValue(unionVec[i], this->getValue(unionVec[i]) + x.getValue(unionVec[i]));
	}

	return *this;
}

//!!!it turns out we do not actually have to make += so complicated so as to find the common indices.
//!!!We are dealing with an operator method, i.e. we only need to add from x to the operator we are working on
//thus a quicker solution could be
/* template<class T> SparseVector<T>& SparseVector<T>::operator+= (SparseVector<T> const& x) {
	unsigned int x_n_nonzero = x.nonZeroes;
	for (int i = 0; i < x_n_nonzero; i++) {
		this->setValue(x.indexNonZero(i), this->getValue(x.indexNonZero(i)) + x.getValue(x.indexNonZero(i)));
	}
	return *this;
} */


//!!! we decide to implement -= this way
//subtracts x from the current vector
template<class T> SparseVector<T>& SparseVector<T>::operator-= (SparseVector<T> const& x) {
	unsigned int x_n_nonzero = x.nonZeroes();
	for (int i = 0; i < x_n_nonzero; i++) {
		this->setValue(x.indexNonZero(i), this->getValue(x.indexNonZero(i)) - x.getValue(x.indexNonZero(i)));
	}
	return *this;
}

////////////////////////////

// computes z= x+y, equivalent to z=x, z+=y
template<class T> SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y) {
	assert(x.size() == y.size());

	SparseVector<T> z(x);
	return z+=y;
}

// computes z= x-y, equivalent to z=x, z-=y
template<class T> SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y) {
	assert(x.size() == y.size());

	SparseVector<T> z(x);
	return z-=y;
}


// computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
// The result is a dense vector.
template<class T> Vector<T> operator*(Matrix<T> const& A, SparseVector<T> const& x) {
	//fairly direct copying of functionality from Matrix.hpp and submission 1.
	unsigned int original_vector_size = x.size();
	assert(A.GetNumberOfColumns() == original_vector_size);

	int new_vector_length = A.GetNumberOfRows();
	Vector<T> new_vector(new_vector_length);

	for (int i = 0; i < new_vector_length; i++)	{
		for (int j = 0; j < original_vector_size; j++) {
			//note use of getValue
			new_vector[i] += A(i,j)*x.getValue(j);
		}
	}

	return new_vector;
}


// computes the matrix-vector product of a dense matrix and sparse vector z=x^TA.
// The result is a dense vector.
template<class T> Vector<T> operator*(SparseVector<T> const& x, Matrix<T> const& A) {
	//once again, fairly direct copy of functionality from Matrix.hpp
	//??? careful of unsigned int vs int!
	unsigned int original_vector_size = x.size();
	assert(original_vector_size == A.GetNumberOfRows());

	int new_vector_length = A.GetNumberOfColumns();
	Vector<T> new_vector(new_vector_length);

	for (int i = 0; i < new_vector_length; i++)	{
		for (int j = 0; j < original_vector_size; j++) {
			new_vector[i] += x.getValue(j)*A(j,i); //note use of getValue
		}
	}

	return new_vector;
}


#endif
