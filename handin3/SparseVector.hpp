#ifndef SPARSE_VECTOR_HPP
#define SPARSE_VECTOR_HPP

#include "Vector.hpp"
#include "Matrix.hpp"

#include <cassert>
#include <cmath>
#include <vector>
#include <algorithm>


template<class T> class SparseVector{
private:
	unsigned int mDim;
	std::vector<unsigned int> mIndices;
	std::vector<T> mValues;

public:
	//creates an empty vector of dimensionality 0.
	SparseVector() : mDim(0) {
		//default dim 0 constructor
	}

	// Creates a vector of dimensionality dim. It starts with 0 nonzero elements
	// which need to be set using setValue
	SparseVector(unsigned int dim) : mDim(dim) {
		//set dim constructor
	}

	// assignment operators and copy constructor should be automatically
	// generated by the compiler when using a std::vector for internal storing.
	// However, test that assignment works!

	//sets the value v_i of the vector. if it does not exist it is added
	void setValue(unsigned int index, T value) {
		//???What if we have value = 0?!!!!
		//!!! <- assignment says doesn't matter.


		//mDim = max(mDim,index), such that mDim is atleast of size index 
		//note the +1 as a request for index 8 requires a dim 9 SparseVector

		/////////

		//mDim = (mDim>=index+1) ? mDim : index+1; //!!! <----------------------------- Maybe we do not want to grow SparseVector in this way?


		/////////

		if (mIndices.size() == 0) {
			//there are no other non-zero entries.
			//we insert the index and value provided directly.
			
			mValues.push_back(value);
			mIndices.push_back(index);

	/* 		if (value != 0) {
				mValues.push_back(value);
				mIndices.push_back(index);
			} */

			//for mIndices.size() != 0 "else case" below, method below would work if not for segmentation
			//problems with the conditional checking whether bound content is equal to index in case of the "empty vector".
			//!!! <- (see tests)

		} else {
			//there are other non-zero entries.
			//check whether 

			//bound is iterator of the smallest index i for which i>=index
			auto bound = std::lower_bound(mIndices.begin(), mIndices.end(), index);

			//[i]-style index location of insertion in mIndices 
			//(how long have we 'stepped' relative to the beginning of mIndices to find bound)
			unsigned int relative_steps_in_i = bound - mIndices.begin(); 

			auto val_it = mValues.begin();
			//??? what if value = 0 ?
			if (*bound == index) {
				//index is in mI, thus erase mV at bound and insert val at location of mValues corresponding to bound location in mIndices.
				//!!! <- note required use of a mValues iterator, as this otherwise yields a convertion error 
				//!!! <- (you can not iterate on a double object with an int iterator)
				mValues.erase(val_it+relative_steps_in_i);
			} else {
				//index is not in mI, thus index in mI after(!) bound, and  insert val in mV after(!) bound.
				mIndices.insert(bound, index);
			}
			//either way, insert value after bound.
			mValues.insert(val_it+relative_steps_in_i, value);
		}
	}

	//returns the value v_i of the vector. Returns 0 if the value is not stored
	T getValue(unsigned int index) const {
		auto search_it = std::find(mIndices.begin(), mIndices.end(), index);
		if (search_it != mIndices.end()) {
			int position_found = search_it - mIndices.begin();
			return mValues[position_found];

			//auto mValues_begin_it = mValues.begin();
			//return *(mValues_begin_it + position_found);
		} else {
			return 0;
		}
	}

	//returns the dimensionality of the vector
	unsigned int size() const {
		return mDim;
	}

	// returns the number stored elements
	unsigned int nonZeroes() const {
		return (unsigned int) (mIndices.size());
	}
	//returns the index of the ith stored nonzero entry (in increasing order)
	unsigned int indexNonZero(unsigned int i) const {
		return mIndices[i];
	}
	//returns the value of the ith stored nonzero entry (in increasing order)
	T valueNonZero(unsigned int i) const {
		return mValues[i];
	}

	//adds x too the current vector
	SparseVector<T>& operator+= (SparseVector<T> const& x) {

		//Potentially, we could allow addition of unequal sized SVs (but that would be a somewhat off += operator)
		//by expanding the dimension (adding zeros) of the one, to the size of the other.
		//We however do a simpler version of asserting them to be of the same size.
		assert(mDim == x.mDim);

		//two different approaches: 
			//1. 
				//create a std::vector<unsigned int> unionVec which is the union of mIndices and x.mIndides
				//sort this union vector.
				//create unsigned int result_size = unionVec.size();
				//create a std::vector<T> vals(result_size), for values.
				//for (int i = 0; i < result_size; i++) { vals[i] = this.getValue(unionVec[i]) + x.getValue(unionVec[i]); }
				//with unionVec and vals, we may thus create SparseVector<T> result(mDim);
				//then: for (unsigned int i = 0; i < result_size; i++) {	result.setValue(unionVec[i],vals[i]); }
				//return result;
				
			//2. 
				//create std::vector<unsigned int> indices, and std::vector<T> vals; 
				//loop over pairwise entries of of mIndices and x.mIndices:
				//start off by looping over all entries of x.mIndices. For each of these entries, loop over all entries of mIndices
				//for each entry of x.mIndices, if there is a equal entry in mIndices, save a record of their value summation,... 
				//...delete previous entry of mValues corresponding to the index, and insert the summation
				//if for the entry of x.mIndices, no equal mIndices entry can be found, (i.e. there's an entry at a location in x which is not in this),...
				//...add the index (at the correct place) to mIndices, and add the of x at the index to mValues as well. 
				//by such a method, all entries (think Venn-diagram of this \cap x \cup x\not this) will be added to mValues.
				//and as mValues and mIndices already contain their respective entries associated with this, we can return this.  
		
		//we go with implementing 1.

		std::vector<unsigned int> unionVec(this->mIndices); 
		std::vector<unsigned int> const x_index(x.mIndices);

		//add the entries of x_index to the end of this.mIndices, thus collecting all non-zero indices
		unionVec.insert(unionVec.end(), x_index.begin(), x_index.end());

		//unionVec will however not be sorted, and may have multiple occurances of the same entry.
		//Thus, we sort unionVec
		std::sort(unionVec.begin(),unionVec.end());

		//and then we remove duplicate entries, such that only one of each unique entry appears
		unionVec.erase(std::unique(unionVec.begin(), unionVec.end()), unionVec.end());

		//get the size of the resulting union of the two index-vectors
		unsigned int unionVec_size = unionVec.size();
		
		//create a std::vector<T> vector for the non-zero values of the SparseVector to be returned
		std::vector<T> vals(unionVec_size);

		//loop over the union indices and collect the values.
		for (unsigned int i = 0; i < unionVec_size; i++) {
			this->setValue(unionVec[i], this->getValue(unionVec[i]) + x.getValue(unionVec[i]));
		}

		return *this;
	}

	//!!!it turns out we do not actually have to make += so complicated so as to find the common indices.
	//!!!We are dealing with an operator method, i.e. we only need to add from x to the operator we are working on
	//thus a more elegant solution based on thsi could be implemented for -=

	//subtracts x from the current vector
	SparseVector<T>& operator-= (SparseVector<T> const& x) {
		unsigned int x_n_nonzero = x.nonZeroes();
		for (int i = 0; i < x_n_nonzero; i++) {
			this->setValue(x.indexNonZero(i), this->getValue(x.indexNonZero(i)) - x.getValue(x.indexNonZero(i)));
		}
		return *this;
	}
};


// computes z= x+y, equivalent to z=x, z+=y
template<class T>
SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y) {
	assert(x.size() == y.size());

	SparseVector<T> z(x);
	return z+=y;
}

// computes z= x-y, equivalent to z=x, z-=y
template<class T>
SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y) {
	assert(x.size() == y.size());

	SparseVector<T> z(x);
	return z-=y;
}

// computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
// The result is a dense vector.
template<class T>
Vector<T> operator* (Matrix<T> const& A, SparseVector<T> const& x) {
	//fairly direct copying of functionality from Matrix.hpp and submission 1.
	unsigned int original_vector_size = x.size();
	assert(A.GetNumberOfColumns() == original_vector_size);

	int new_vector_length = A.GetNumberOfRows();
	Vector<T> new_vector(new_vector_length);

	for (int i = 0; i < new_vector_length; i++)	{
		for (int j = 0; j < original_vector_size; j++) {
			//note use of getValue
			new_vector[i] += A(i,j)*x.getValue(j);
		}
	}

	return new_vector;
}

// computes the matrix-vector product of a dense matrix and sparse vector z=x^TA.
// The result is a dense vector.
template<class T>
Vector<T> operator* (SparseVector<T> const& x, Matrix<T> const& A) {
	//once again, fairly direct copy of functionality from Matrix.hpp
	//??? careful of unsigned int vs int!
	unsigned int original_vector_size = x.size();
	assert(original_vector_size == A.GetNumberOfRows());

	int new_vector_length = A.GetNumberOfColumns();
	Vector<T> new_vector(new_vector_length);

	for (int i = 0; i < new_vector_length; i++)	{
		for (int j = 0; j < original_vector_size; j++) {
			new_vector[i] += x.getValue(j)*A(j,i); //note use of getValue
		}
	}

	return new_vector;
}


#endif
